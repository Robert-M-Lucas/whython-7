Index: src/compiler/compile_functions/call_function.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::ast::operators::Operator;\nuse crate::basic_ast::symbol::BasicSymbol;\nuse crate::compiler::compile_functions::name_handler::NameHandler;\nuse crate::compiler::compile_functions::operators::evaluate_operation;\nuse crate::compiler::compile_functions::{evaluate, FunctionHolder, Line};\nuse crate::parser::line_info::LineInfo;\nuse crate::processor::processor::ProcessorError;\nuse crate::processor::type_builder::{Type, TypedFunction};\n\npub fn call_function(\n    function: &Box<dyn TypedFunction>,\n    start_line: &LineInfo,\n    default_arg: Option<(isize, (isize, usize))>,\n    args: &Vec<Vec<(BasicSymbol, LineInfo)>>,\n    lines: &mut Vec<Line>,\n    name_handler: &mut NameHandler,\n    function_holder: &FunctionHolder,\n    return_into: Option<(isize, (isize, usize))>,\n) -> Result<Option<(isize, (isize, usize))>, ProcessorError> {\n    name_handler.use_function(function);\n    let target_args = function.get_args();\n    let mut args_len = args.len();\n    if default_arg.is_some() {\n        args_len += 1;\n    }\n\n    if args_len > target_args.len() {\n        return Err(ProcessorError::BadArgCount(\n            // TODO: Bad line location\n            args[target_args.len() - (args_len - args.len())][0]\n                .1\n                .clone(),\n            target_args.len(),\n            args_len,\n            function.get_line(),\n        ));\n    }\n    if args_len < target_args.len() {\n        if args.is_empty() {\n            return Err(ProcessorError::BadArgCount(\n                // TODO: Bad line location\n                start_line.clone(),\n                target_args.len(),\n                args_len,\n                function.get_line(),\n            ));\n        } else {\n            return Err(ProcessorError::BadArgCount(\n                // TODO: Bad line location\n                args[args.len() - 1].last().unwrap().1.clone(),\n                target_args.len(),\n                args_len,\n                function.get_line(),\n            ));\n        }\n    }\n\n    let mut call_args = Vec::new();\n    if let Some(default_arg) = default_arg {\n        let default_arg = if default_arg.1 .1 == 0 && target_args[0].1 .1 == 1 {\n            // TODO: Bad operator line\n            let into = name_handler.add_local_variable(None, target_args[0].1, lines)?;\n            evaluate_operation(\n                default_arg,\n                (&Operator::And, start_line),\n                None,\n                lines,\n                name_handler,\n                function_holder,\n                Some((into, target_args[0].1)),\n            )?\n            .unwrap()\n        } else {\n            default_arg\n        };\n        if default_arg.1 != target_args[0].1 {\n            panic!(\"Default arg doesn't match first target arg\")\n        }\n        call_args.push((\n            default_arg.0,\n            name_handler.type_table().get_type_size(default_arg.1)?,\n        ));\n    }\n    for arg in args {\n        let evaluated = evaluate::evaluate(arg, lines, name_handler, function_holder, None)?;\n        // println!(\"{:?}\", evaluated);\n        if evaluated.is_none() {\n            return Err(ProcessorError::DoesntEvaluate(arg[0].1.clone()));\n        }\n        let evaluated = evaluated.unwrap();\n        if evaluated.1 != target_args[call_args.len()].1 {\n            return Err(ProcessorError::BadArgType(\n                arg[0].1.clone(),\n                name_handler\n                    .type_table()\n                    .get_type(target_args[call_args.len()].1 .0)\n                    .unwrap()\n                    .get_indirect_name(target_args[call_args.len()].1 .1)\n                    .to_string(),\n                name_handler\n                    .type_table()\n                    .get_type(evaluated.1 .0)\n                    .unwrap()\n                    .get_indirect_name(evaluated.1 .1)\n                    .to_string(),\n                function.get_line(),\n            ));\n        }\n        call_args.push((\n            evaluated.0,\n            name_handler.type_table().get_type_size(evaluated.1)?,\n        ));\n    }\n\n    Ok(if let Some(return_type) = function.get_return_type() {\n        if return_into.is_some() && return_into.unwrap().1 != return_type {\n            return Err(ProcessorError::BadEvaluatedType(\n                start_line.clone(),\n                name_handler\n                    .type_table()\n                    .get_type(return_into.unwrap().1 .0)\n                    .unwrap()\n                    .get_indirect_name(return_into.unwrap().1 .1)\n                    .to_string(),\n                name_handler\n                    .type_table()\n                    .get_type(return_type.0)\n                    .unwrap()\n                    .get_indirect_name(return_type.1)\n                    .to_string(),\n            ));\n        }\n        let return_into = if let Some(return_into) = return_into {\n            (\n                return_into.0,\n                name_handler.type_table().get_type_size(return_type)?,\n            )\n        } else {\n            (\n                name_handler.add_local_variable(None, return_type, lines)?,\n                name_handler.type_table().get_type_size(return_type)?,\n            )\n        };\n\n        if function.is_inline() {\n            let mut inline_args: Vec<_> = call_args.into_iter().map(|x| x.0).collect();\n            inline_args.push(return_into.0);\n            lines.push(Line::InlineAsm(function.get_inline(inline_args)));\n        } else {\n            lines.push(Line::ReturnCall(\n                function.get_id(),\n                -(name_handler.local_variable_space() as isize),\n                call_args,\n                name_handler.type_table().get_type_size(return_type)?,\n                return_into.0,\n            ))\n        }\n\n        Some((return_into.0, return_type))\n    } else {\n        if let Some(return_into) = return_into {\n            return Err(ProcessorError::BadEvaluatedType(\n                start_line.clone(),\n                name_handler\n                    .type_table()\n                    .get_type(return_into.1 .0)\n                    .unwrap()\n                    .get_indirect_name(return_into.1 .1)\n                    .to_string(),\n                \"None\".to_string(),\n            ));\n        }\n\n        if function.is_inline() {\n            let inline_args: Vec<_> = call_args.into_iter().map(|x| x.0).collect();\n            lines.push(Line::InlineAsm(function.get_inline(inline_args)));\n        } else {\n            lines.push(Line::NoReturnCall(function.get_id(), -(name_handler.local_variable_space() as isize), call_args, 0))\n        }\n\n        None\n    })\n}\n
===================================================================
diff --git a/src/compiler/compile_functions/call_function.rs b/src/compiler/compile_functions/call_function.rs
--- a/src/compiler/compile_functions/call_function.rs	
+++ b/src/compiler/compile_functions/call_function.rs	
@@ -175,7 +175,12 @@
             let inline_args: Vec<_> = call_args.into_iter().map(|x| x.0).collect();
             lines.push(Line::InlineAsm(function.get_inline(inline_args)));
         } else {
-            lines.push(Line::NoReturnCall(function.get_id(), -(name_handler.local_variable_space() as isize), call_args, 0))
+            lines.push(Line::NoReturnCall(
+                function.get_id(),
+                -(name_handler.local_variable_space() as isize),
+                call_args,
+                0,
+            ))
         }
 
         None
Index: src/processor/type_builder.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::processor::preprocess::{PreProcessFunction, PreprocessSymbol};\nuse crate::processor::processor::ProcessorError;\n\nuse std::collections::HashMap;\n\nuse crate::ast::literals::Literal;\nuse crate::basic_ast::symbol::BasicSymbol;\nuse crate::parser::line_info::LineInfo;\nuse crate::processor::custom_types::{Bool, Int};\n\nuse crate::processor::user_type::UserType;\nuse crate::utils::align;\n\nstruct UninitialisedType {\n    pub path: LineInfo,\n    pub id: isize,\n    pub attributes: Vec<(String, Result<(isize, usize), ((String, usize), LineInfo)>)>,\n}\n\nimpl UninitialisedType {\n    pub fn new(\n        path: LineInfo,\n        id: isize,\n        attributes: Vec<(String, LineInfo, (String, usize), LineInfo)>,\n    ) -> UninitialisedType {\n        let mut attributes_processed = Vec::new();\n        for (attr_name, _attr_line, attr_type, attr_type_line) in attributes {\n            attributes_processed.push((attr_name, Err((attr_type, attr_type_line))));\n        }\n\n        UninitialisedType {\n            path,\n            id,\n            attributes: attributes_processed,\n        }\n    }\n\n    // pub fn to_initialised(self) -> Result<UserType, ProcessorError> {\n    //     let mut attributes_processed = Vec::new();\n    //     for (attr_name, attr_type) in self.attributes {\n    //         if attr_type.is_err() {\n    //             let (attr_type, attr_type_line) = attr_type.unwrap_err();\n    //             return Err(TypeNotFoundError(self.path, attr_type_line, attr_type));\n    //         }\n    //\n    //         attributes_processed.push((attr_name, attr_type.unwrap()))\n    //     }\n    //\n    //     Ok(UserType::new(self.name, self.id, attributes_processed))\n    // }\n}\n\npub trait Type {\n    fn get_id(&self) -> isize;\n\n    fn get_name(&self) -> &str;\n\n    fn get_indirect_name(&self, indirection: usize) -> String {\n        let mut out = String::new();\n        for _ in 0..indirection {\n            out.push('$');\n        }\n        out += self.get_name();\n        out\n    }\n\n    fn get_size(\n        &self,\n        type_table: &TypeTable,\n        path: Option<Vec<isize>>,\n    ) -> Result<usize, ProcessorError>;\n\n    fn instantiate(\n        &self,\n        literal: Option<&Literal>,\n        local_address: isize,\n    ) -> Result<Vec<String>, ProcessorError>;\n\n    fn get_user_type(&self) -> Option<&UserType> {\n        None\n    }\n\n    fn try_set_destructor(\n        &mut self,\n        line_info: &LineInfo,\n        func: isize,\n    ) -> Result<(), ProcessorError> {\n        Err(ProcessorError::CantSetBuiltinDestructor(line_info.clone()))\n    }\n\n    fn get_destructor(&self) -> Option<isize> {\n        None\n    }\n}\n\n// pub struct TypeIdentifier {\n//     id: isize,\n//     indirections: usize,\n// }\n\npub struct TypeTable {\n    types: HashMap<isize, Box<dyn Type>>,\n}\n\nimpl TypeTable {\n    pub fn new() -> TypeTable {\n        TypeTable {\n            types: HashMap::new(),\n        }\n    }\n\n    pub fn add_builtin(mut self) -> TypeTable {\n        self.add_type(Int::new().get_id(), Box::new(Int::new()));\n        self.add_type(Bool::new().get_id(), Box::new(Bool::new()));\n        self\n    }\n\n    pub fn add_type(&mut self, id: isize, type_: Box<dyn Type>) {\n        if self.types.insert(id, type_).is_some() {\n            panic!(\"Attempted to override type\")\n        }\n    }\n\n    pub fn get_id_by_name(&self, name: &str) -> Option<isize> {\n        for (id, type_) in &self.types {\n            if type_.get_name() == name {\n                return Some(*id);\n            }\n        }\n        None\n    }\n\n    pub fn get_type(&self, id: isize) -> Option<&Box<dyn Type>> {\n        self.types.get(&id)\n    }\n\n    pub fn get_type_mut(&mut self, id: isize) -> Option<&mut Box<dyn Type>> {\n        self.types.get_mut(&id)\n    }\n\n    pub fn get_type_size(&self, id: (isize, usize)) -> Result<usize, ProcessorError> {\n        if id.1 != 0 {\n            return Ok(8);\n        }\n        self.types.get(&id.0).unwrap().get_size(self, None)\n    }\n}\n\n#[derive(Debug)]\npub struct UserTypedFunction {\n    pub id: isize,\n    pub name: String,\n    pub line: LineInfo,\n    pub args: Vec<(String, (isize, usize))>,\n    pub return_type: Option<(isize, usize)>,\n    pub contents: Option<Vec<(BasicSymbol, LineInfo)>>,\n}\n\nimpl TypedFunction for UserTypedFunction {\n    fn get_id(&self) -> isize {\n        self.id\n    }\n\n    fn get_name(&self) -> &str {\n        &self.name\n    }\n\n    fn get_args(&self) -> &[(String, (isize, usize))] {\n        &self.args\n    }\n\n    fn get_line(&self) -> LineInfo {\n        self.line.clone()\n    }\n\n    fn get_return_type(&self) -> Option<(isize, usize)> {\n        self.return_type\n    }\n\n    fn is_inline(&self) -> bool {\n        false\n    }\n\n    fn contents(&self) -> &Vec<(BasicSymbol, LineInfo)> {\n        self.contents.as_ref().unwrap()\n    }\n\n    fn take_contents(&mut self) -> Vec<(BasicSymbol, LineInfo)> {\n        self.contents.take().unwrap()\n    }\n\n    fn get_inline(&self, _args: Vec<isize>) -> Vec<String> {\n        panic!()\n    }\n}\n\npub trait TypedFunction {\n    fn get_id(&self) -> isize {\n        panic!();\n    }\n    fn get_name(&self) -> &str;\n    fn get_args(&self) -> &[(String, (isize, usize))];\n    fn get_line(&self) -> LineInfo;\n    fn get_args_positioned(&self, type_table: &TypeTable) -> Result<Vec<(String, isize, (isize, usize))>, ProcessorError> {\n        let mut offset = 16isize;\n        if let Some(return_type) = self.get_return_type() {\n            offset += type_table.get_type_size(return_type)? as isize;\n            offset = align(offset, 8);\n        }\n        let mut output = Vec::new();\n\n        for (name, _type) in self.get_args() {\n            output.push((name.clone(), offset, *_type));\n            offset += type_table.get_type_size(*_type).unwrap() as isize;\n            offset = align(offset, 8);\n        }\n\n        Ok(output)\n    }\n    fn get_return_type(&self) -> Option<(isize, usize)>;\n    fn is_inline(&self) -> bool;\n    fn contents(&self) -> &Vec<(BasicSymbol, LineInfo)> {\n        panic!()\n    }\n    fn take_contents(&mut self) -> Vec<(BasicSymbol, LineInfo)> {\n        panic!()\n    }\n    fn get_inline(&self, _args: Vec<isize>) -> Vec<String> {\n        panic!();\n    }\n}\n\n// #[derive(Debug)]\n// pub enum TypedImplsFns {\n//     Impl(isize, Vec<TypedFunction>),\n//     Fn(TypedFunction)\n// }\n\npub fn build_types(\n    pre_ast: Vec<PreprocessSymbol>,\n) -> Result<\n    (\n        TypeTable,\n        HashMap<Option<isize>, HashMap<String, isize>>,\n        HashMap<isize, Box<dyn TypedFunction>>,\n    ),\n    ProcessorError,\n> {\n    let mut remaining_pre_ast = Vec::new();\n\n    let mut uninitialised_types: HashMap<String, UninitialisedType> = HashMap::new();\n    let mut type_counter = 0isize;\n\n    let mut type_table = TypeTable::new().add_builtin();\n\n    for symbol in pre_ast {\n        match symbol {\n            PreprocessSymbol::Struct(line, name, args) => {\n                uninitialised_types.insert(\n                    name.clone(),\n                    UninitialisedType::new(line, type_counter, args),\n                );\n                type_counter += 1;\n            }\n            other => remaining_pre_ast.push(other),\n        }\n    }\n\n    let mut uninitialised_types: Vec<_> = uninitialised_types.into_iter().collect();\n\n    for i in 0..uninitialised_types.len() {\n        'attr_loop: for a in 0..uninitialised_types[i].1.attributes.len() {\n            for j in 0..uninitialised_types.len() {\n                if uninitialised_types[i].1.attributes[a]\n                    .1\n                    .as_ref()\n                    .unwrap_err()\n                    .0\n                     .0\n                    == uninitialised_types[j].0\n                {\n                    uninitialised_types[i].1.attributes[a].1 = Ok((\n                        uninitialised_types[j].1.id,\n                        uninitialised_types[i].1.attributes[a]\n                            .1\n                            .as_ref()\n                            .unwrap_err()\n                            .0\n                             .1,\n                    ));\n                    continue 'attr_loop;\n                }\n            }\n\n            if let Some(id) = type_table.get_id_by_name(\n                &uninitialised_types[i].1.attributes[a]\n                    .1\n                    .as_ref()\n                    .unwrap_err()\n                    .0\n                     .0,\n            ) {\n                uninitialised_types[i].1.attributes[a].1 = Ok((\n                    id,\n                    uninitialised_types[i].1.attributes[a]\n                        .1\n                        .as_ref()\n                        .unwrap_err()\n                        .0\n                         .1,\n                ));\n                continue 'attr_loop;\n            }\n\n            let type_ = uninitialised_types.remove(i).1;\n            let (_line, mut attributes) = (type_.path, type_.attributes);\n            let (type_name, line) = attributes.remove(a).1.unwrap_err();\n            return Err(ProcessorError::TypeNotFound(line, type_name.0));\n        }\n    }\n\n    for (name, type_) in uninitialised_types {\n        let (_id, line, attributes) = (type_.id, type_.path, type_.attributes);\n\n        let mut attributes_processed = Vec::new();\n        for (attr_name, attr_type) in attributes {\n            if attr_type.is_err() {\n                let (attr_type, attr_type_line) = attr_type.unwrap_err();\n                return Err(ProcessorError::TypeNotFound(attr_type_line, attr_type.0));\n            }\n\n            attributes_processed.push((attr_name, attr_type.unwrap()))\n        }\n\n        type_table.add_type(\n            type_.id,\n            Box::new(UserType::new(\n                name,\n                type_.id,\n                line,\n                attributes_processed,\n                None,\n            )),\n        )\n    }\n\n    let mut typed_fns = HashMap::new();\n    let mut fn_name_map = HashMap::new();\n    fn_name_map.insert(None, HashMap::new());\n    let mut id_counter: isize = 1;\n    for symbol in remaining_pre_ast {\n        match symbol {\n            PreprocessSymbol::Impl(line, type_name, functions) => {\n                let type_id = type_table\n                    .get_id_by_name(&type_name)\n                    .ok_or(ProcessorError::BadImplType(line))?;\n                fn_name_map\n                    .entry(Some(type_id))\n                    .or_insert_with(HashMap::new);\n                for (function, line) in functions {\n                    fn_name_map\n                        .get_mut(&Some(type_id))\n                        .unwrap()\n                        .insert(function.0.clone(), id_counter);\n\n                    if function.0 == \"destroy\" {\n                        type_table\n                            .get_type_mut(type_id)\n                            .unwrap()\n                            .try_set_destructor(&line, id_counter)?;\n                    }\n\n                    typed_fns.insert(\n                        id_counter,\n                        process_function(function, &type_table, id_counter, Some(type_id), line)?,\n                    );\n                    id_counter += 1;\n                }\n            }\n            PreprocessSymbol::Fn(line, function) => {\n                let id = if &function.0 == \"main\" {\n                    0\n                } else {\n                    id_counter += 1;\n                    id_counter - 1\n                };\n                fn_name_map\n                    .get_mut(&None)\n                    .unwrap()\n                    .insert(function.0.clone(), id);\n                typed_fns.insert(id, process_function(function, &type_table, id, None, line)?);\n                id_counter += 1;\n            }\n            _ => panic!(\"Expected Impl of Functions\"),\n        }\n    }\n\n    if let Some(main) = typed_fns.get(&0) {\n        if !main.get_args().is_empty() {\n            return Err(ProcessorError::MainFunctionParams);\n        }\n        if main.get_return_type() != Some((-1, 0)) {\n            return Err(ProcessorError::MainFunctionBadReturn);\n        }\n    } else {\n        return Err(ProcessorError::NoMainFunction);\n    }\n\n    Ok((type_table, fn_name_map, typed_fns))\n}\n\nfn process_function(\n    function: PreProcessFunction,\n    type_table: &TypeTable,\n    id: isize,\n    _impl_type: Option<isize>,\n    line: LineInfo,\n) -> Result<Box<dyn TypedFunction>, ProcessorError> {\n    let (name, args, return_type, contents) = function;\n\n    let mut args_processed: Vec<(String, (isize, usize))> = Vec::new();\n\n    for (param_name, param_line, type_name, indirection, type_line) in args {\n        for (existing_arg, _) in &args_processed {\n            if &param_name == existing_arg {\n                return Err(ProcessorError::ParameterNameInUse(param_line, param_name));\n            }\n        }\n        args_processed.push((\n            param_name,\n            (\n                type_table\n                    .get_id_by_name(&type_name)\n                    .ok_or(ProcessorError::TypeNotFound(type_line, type_name))?,\n                indirection,\n            ),\n        ));\n    }\n\n    let return_type = if let Some((type_name, type_line)) = return_type {\n        Some((\n            type_table\n                .get_id_by_name(&type_name.0)\n                .ok_or(ProcessorError::TypeNotFound(type_line, type_name.0))?,\n            type_name.1,\n        ))\n    } else {\n        None\n    };\n\n    Ok(Box::new(UserTypedFunction {\n        id,\n        name,\n        line,\n        args: args_processed,\n        return_type,\n        contents: Some(contents),\n    }))\n}\n
===================================================================
diff --git a/src/processor/type_builder.rs b/src/processor/type_builder.rs
--- a/src/processor/type_builder.rs	
+++ b/src/processor/type_builder.rs	
@@ -201,7 +201,10 @@
     fn get_name(&self) -> &str;
     fn get_args(&self) -> &[(String, (isize, usize))];
     fn get_line(&self) -> LineInfo;
-    fn get_args_positioned(&self, type_table: &TypeTable) -> Result<Vec<(String, isize, (isize, usize))>, ProcessorError> {
+    fn get_args_positioned(
+        &self,
+        type_table: &TypeTable,
+    ) -> Result<Vec<(String, isize, (isize, usize))>, ProcessorError> {
         let mut offset = 16isize;
         if let Some(return_type) = self.get_return_type() {
             offset += type_table.get_type_size(return_type)? as isize;
Index: src/compiler/compile_functions/process_lines.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::ast::keywords::Keyword;\nuse crate::ast::operators::Operator;\nuse crate::basic_ast::punctuation::Punctuation;\nuse crate::basic_ast::symbol::{BasicSymbol, NameType};\nuse crate::compiler::compile_functions::assignment::process_assignment;\nuse crate::compiler::compile_functions::name_handler::NameHandler;\nuse crate::compiler::compile_functions::{evaluate, FunctionHolder, Line};\nuse crate::compiler::generate_asm::{get_function_sublabel, get_local_address};\nuse crate::parser::line_info::LineInfo;\nuse crate::processor::custom_types::Bool;\nuse crate::processor::processor::ProcessorError;\nuse crate::processor::type_builder::Type;\n\nuse itertools::Itertools;\nuse std::fs;\n\npub fn process_lines(\n    section: &[(BasicSymbol, LineInfo)],\n    current_id: isize,\n    return_type: Option<(isize, usize)>,\n    lines: &mut Vec<Line>,\n    name_handler: &mut NameHandler,\n    function_holder: &FunctionHolder,\n    mut break_label: Option<String>,\n) -> Result<bool, ProcessorError> {\n    let mut last_return = false;\n\n    #[cfg(debug_assertions)]\n    let mut prev_line = None;\n    for line in section.split(|x| matches!(x.0, BasicSymbol::Punctuation(Punctuation::Semicolon))) {\n        if line.is_empty() {\n            continue;\n        }\n\n        #[cfg(debug_assertions)]\n        {\n            let new_line = line.last().unwrap().1.line();\n            let file = line.last().unwrap().1.file().unwrap();\n            let start = if let Some(prev_line) = prev_line {\n                prev_line\n            } else {\n                line.first().unwrap().1.line()\n            };\n\n            let text = fs::read_to_string(file.as_path()).unwrap();\n            let text = &text.lines().collect_vec()[(start - 1)..(new_line)];\n\n            for l in text {\n                lines.push(Line::Annotation(l.to_string()));\n            }\n\n            prev_line = Some(new_line + 1);\n        }\n\n        last_return = false;\n\n        if line.len() > 2\n            && matches!(&line[0].0, BasicSymbol::Operator(Operator::Product))\n            && matches!(&line[2].0, BasicSymbol::Assigner(_))\n        {\n            process_assignment(lines, name_handler, function_holder, &line[1..], true)?;\n            continue;\n        }\n\n        if line.len() > 1 && matches!(&line[1].0, BasicSymbol::Assigner(_)) {\n            process_assignment(lines, name_handler, function_holder, line, false)?;\n            continue;\n        }\n\n        match &line[0].0 {\n            BasicSymbol::Keyword(Keyword::Return) => {\n                last_return = true;\n                if line.len() == 1 {\n                    if return_type.is_none() {\n                        name_handler.destroy_local_variables(lines)?;\n                        lines.push(Line::Return(None));\n                        continue;\n                    } else {\n                        return Err(ProcessorError::NoneReturnOnTypedFunction(line[0].1.clone()));\n                    }\n                } else if return_type.is_none() {\n                    return Err(ProcessorError::TypeReturnOnVoidFunction(line[1].1.clone()));\n                }\n                let return_type = return_type.unwrap();\n\n                let return_into = name_handler.add_local_variable(None, return_type, lines)?;\n                let return_value = evaluate::evaluate(\n                    &line[1..],\n                    lines,\n                    name_handler,\n                    function_holder,\n                    Some((return_into, return_type)),\n                )?;\n                if return_value.is_none() {\n                    return Err(ProcessorError::DoesntEvaluate(line[1].1.clone()));\n                }\n                let return_value = return_value.unwrap();\n                if return_type != return_value.1 {\n                    return Err(ProcessorError::BadReturnType(\n                        line[1].1.clone(),\n                        name_handler\n                            .type_table()\n                            .get_type(return_type.0)\n                            .unwrap()\n                            .get_indirect_name(return_type.1)\n                            .to_string(),\n                        name_handler\n                            .type_table()\n                            .get_type(return_value.1 .0)\n                            .unwrap()\n                            .get_indirect_name(return_value.1 .1)\n                            .to_string(),\n                    ));\n                }\n                name_handler.destroy_local_variables(lines)?;\n                lines.push(Line::Return(Some((return_value.0, name_handler.type_table().get_type_size(return_value.1)?))));\n            }\n            BasicSymbol::Keyword(Keyword::Let) => {\n                if line.len() < 2 {\n                    return Err(ProcessorError::LetNoName(line[0].1.clone()));\n                }\n                let BasicSymbol::Name(name) = &line[1].0 else {\n                    return Err(ProcessorError::LetNoName(line[1].1.clone()));\n                };\n\n                if name.len() > 1 {\n                    return Err(ProcessorError::MultipartNameDef(line[1].1.clone()));\n                }\n                let name = &name[0];\n                if name.3 != 0 {\n                    return Err(ProcessorError::NameWithRefPrefix(line[0].1.clone()));\n                }\n\n                if !matches!(&name.2, NameType::Normal) {\n                    return Err(ProcessorError::LetNoName(line[0].1.clone()));\n                }\n                let name = &name.0;\n\n                if line.len() < 4 {\n                    return Err(ProcessorError::NameTypeNotDefined(line[1].1.clone()));\n                }\n                if !matches!(&line[2].0, BasicSymbol::Punctuation(Punctuation::Colon)) {\n                    return Err(ProcessorError::NameTypeNotDefined(line[2].1.clone()));\n                }\n\n                let BasicSymbol::Name(type_name) = &line[3].0 else {\n                    return Err(ProcessorError::NameTypeNotDefined(line[3].1.clone()));\n                };\n\n                if type_name.len() > 1 {\n                    return Err(ProcessorError::MultipartTypeName(line[3].1.clone()));\n                }\n                let type_name = &type_name[0];\n\n                if !matches!(&type_name.2, NameType::Normal) {\n                    return Err(ProcessorError::NameTypeNotDefined(line[3].1.clone()));\n                }\n\n                let type_id = name_handler\n                    .type_table()\n                    .get_id_by_name(&type_name.0)\n                    .ok_or(ProcessorError::TypeNotFound(\n                        line[3].1.clone(),\n                        type_name.0.clone(),\n                    ))?;\n                let addr = name_handler.add_local_variable(None, (type_id, type_name.3), lines)?;\n\n                if line.len() < 6 {\n                    return Err(ProcessorError::LetNoValue(line[3].1.clone()));\n                }\n                if !matches!(&line[4].0, BasicSymbol::Assigner(None)) {\n                    return Err(ProcessorError::LetNoValue(line[4].1.clone()));\n                }\n\n                evaluate::evaluate(\n                    &line[5..],\n                    lines,\n                    name_handler,\n                    function_holder,\n                    Some((addr, (type_id, type_name.3))),\n                )?;\n\n                name_handler.name_variable(name.clone(), addr, (type_id, type_name.3));\n            }\n            BasicSymbol::Keyword(Keyword::While) => {\n                if line.len() < 2 {\n                    return Err(ProcessorError::WhileNoBrackets(line[0].1.clone()));\n                }\n\n                let BasicSymbol::BracketedSection(expr) = &line[1].0 else {\n                    return Err(ProcessorError::WhileNoBrackets(line[1].1.clone()));\n                };\n                let start_label =\n                    get_function_sublabel(current_id, &name_handler.get_uid().to_string());\n                let end_label =\n                    get_function_sublabel(current_id, &name_handler.get_uid().to_string());\n                break_label = Some(end_label.clone());\n\n                lines.push(Line::InlineAsm(vec![format!(\"{}:\", start_label)]));\n                let evaluated =\n                    evaluate::evaluate(expr, lines, name_handler, function_holder, None)?\n                        .ok_or(ProcessorError::DoesntEvaluate(line[1].1.clone()))?;\n                lines.push(Line::InlineAsm(vec![\n                    format!(\"mov rax, qword [{}]\", get_local_address(evaluated.0)),\n                    \"cmp rax, 0\".to_string(),\n                    format!(\"jnz {}\", end_label),\n                ]));\n\n                if evaluated.1 != (Bool::new().get_id(), 0) {\n                    return Err(ProcessorError::BadConditionType(\n                        line[1].1.clone(),\n                        name_handler\n                            .type_table()\n                            .get_type(evaluated.1 .0)\n                            .unwrap()\n                            .get_indirect_name(evaluated.1 .1)\n                            .to_string(),\n                    ));\n                }\n                if line.len() < 3 {\n                    return Err(ProcessorError::WhileNoBraces(line[1].1.clone()));\n                }\n                let BasicSymbol::BracedSection(inner) = &line[2].0 else {\n                    return Err(ProcessorError::WhileNoBraces(line[2].1.clone()));\n                };\n                process_lines(\n                    inner,\n                    current_id,\n                    return_type,\n                    lines,\n                    name_handler,\n                    function_holder,\n                    break_label.clone(),\n                )?;\n                lines.push(Line::InlineAsm(vec![\n                    format!(\"jmp {}\", start_label),\n                    format!(\"{}:\", end_label),\n                ]));\n\n                if line.len() > 3 {\n                    return Err(ProcessorError::WhileMoreAfterBraces(line[3].1.clone()));\n                }\n            }\n            BasicSymbol::Keyword(Keyword::If) => {\n                if line.len() < 2 {\n                    return Err(ProcessorError::IfElifNoBrackets(line[0].1.clone()));\n                }\n\n                let BasicSymbol::BracketedSection(expr) = &line[1].0 else {\n                    return Err(ProcessorError::IfElifNoBrackets(line[1].1.clone()));\n                };\n                let mut next_label =\n                    get_function_sublabel(current_id, &name_handler.get_uid().to_string());\n                let end_label =\n                    get_function_sublabel(current_id, &name_handler.get_uid().to_string());\n\n                let evaluated =\n                    evaluate::evaluate(expr, lines, name_handler, function_holder, None)?\n                        .ok_or(ProcessorError::DoesntEvaluate(line[1].1.clone()))?;\n                if evaluated.1 != (Bool::new().get_id(), 0) {\n                    return Err(ProcessorError::BadConditionType(\n                        line[1].1.clone(),\n                        name_handler\n                            .type_table()\n                            .get_type(evaluated.1 .0)\n                            .unwrap()\n                            .get_indirect_name(evaluated.1 .1)\n                            .to_string(),\n                    ));\n                }\n                lines.push(Line::InlineAsm(vec![\n                    format!(\"mov rax, qword [{}]\", get_local_address(evaluated.0)),\n                    \"cmp rax, 0\".to_string(),\n                    format!(\"jnz {}\", next_label),\n                ]));\n                if line.len() < 3 {\n                    return Err(ProcessorError::IfElifElseNoBraces(line[1].1.clone()));\n                }\n                let BasicSymbol::BracedSection(inner) = &line[2].0 else {\n                    return Err(ProcessorError::IfElifElseNoBraces(line[2].1.clone()));\n                };\n                process_lines(\n                    inner,\n                    current_id,\n                    return_type,\n                    lines,\n                    name_handler,\n                    function_holder,\n                    break_label.clone(),\n                )?;\n\n                let mut i = 3;\n                let mut ended = false;\n                while line.len() > i {\n                    lines.push(Line::InlineAsm(vec![\n                        format!(\"jmp {}\", end_label),\n                        format!(\"{}:\", next_label),\n                    ]));\n\n                    next_label =\n                        get_function_sublabel(current_id, &name_handler.get_uid().to_string());\n\n                    match &line[i].0 {\n                        BasicSymbol::Keyword(Keyword::Elif) => {\n                            if ended {\n                                return Err(ProcessorError::IfElifAfterElse(line[i].1.clone()));\n                            }\n                            i += 1;\n                            if line.len() <= i {\n                                return Err(ProcessorError::IfElifNoBrackets(\n                                    line[i - 1].1.clone(),\n                                ));\n                            }\n\n                            let BasicSymbol::BracketedSection(expr) = &line[i].0 else {\n                                return Err(ProcessorError::IfElifNoBrackets(line[i].1.clone()));\n                            };\n\n                            let evaluated = evaluate::evaluate(\n                                expr,\n                                lines,\n                                name_handler,\n                                function_holder,\n                                None,\n                            )?\n                            .ok_or(ProcessorError::DoesntEvaluate(line[i].1.clone()))?;\n                            if evaluated.1 != (Bool::new().get_id(), 0) {\n                                return Err(ProcessorError::BadConditionType(\n                                    line[i].1.clone(),\n                                    name_handler\n                                        .type_table()\n                                        .get_type(evaluated.1 .0)\n                                        .unwrap()\n                                        .get_indirect_name(evaluated.1 .1)\n                                        .to_string(),\n                                ));\n                            }\n                            lines.push(Line::InlineAsm(vec![\n                                format!(\"mov rax, qword [{}]\", get_local_address(evaluated.0)),\n                                \"cmp rax, 0\".to_string(),\n                                format!(\"jnz {}\", next_label),\n                            ]));\n\n                            i += 1;\n                            if line.len() <= i {\n                                return Err(ProcessorError::IfElifElseNoBraces(\n                                    line[i - 1].1.clone(),\n                                ));\n                            }\n                            let BasicSymbol::BracedSection(inner) = &line[i].0 else {\n                                return Err(ProcessorError::IfElifElseNoBraces(line[i].1.clone()));\n                            };\n                            process_lines(\n                                inner,\n                                current_id,\n                                return_type,\n                                lines,\n                                name_handler,\n                                function_holder,\n                                break_label.clone(),\n                            )?;\n                            i += 1;\n                        }\n                        BasicSymbol::Keyword(Keyword::Else) => {\n                            ended = true;\n                            i += 1;\n                            if line.len() <= i {\n                                return Err(ProcessorError::IfElifElseNoBraces(\n                                    line[i - 1].1.clone(),\n                                ));\n                            }\n                            let BasicSymbol::BracedSection(inner) = &line[i].0 else {\n                                return Err(ProcessorError::IfElifElseNoBraces(line[i].1.clone()));\n                            };\n                            process_lines(\n                                inner,\n                                current_id,\n                                return_type,\n                                lines,\n                                name_handler,\n                                function_holder,\n                                break_label.clone(),\n                            )?;\n                            i += 1;\n                        }\n                        _ => return Err(ProcessorError::ElseMoreAfterBraces(line[i].1.clone())),\n                    }\n                }\n\n                lines.push(Line::InlineAsm(vec![\n                    format!(\"{}:\", next_label),\n                    format!(\"{}:\", end_label),\n                ]));\n            }\n            BasicSymbol::Keyword(Keyword::Elif | Keyword::Else) => {\n                return Err(ProcessorError::RawElifElse(line[0].1.clone()))\n            }\n            BasicSymbol::Keyword(Keyword::Break) => {\n                if line.len() > 1 {\n                    return Err(ProcessorError::BreakLineNotEmpty(line[1].1.clone()));\n                }\n                let Some(break_label) = &break_label else {\n                    return Err(ProcessorError::NothingToBreak(line[0].1.clone()));\n                };\n                lines.push(Line::InlineAsm(vec![format!(\"jmp {}\", break_label)]));\n            }\n            _ => {\n                evaluate::evaluate(line, lines, name_handler, function_holder, None)?;\n            }\n        };\n    }\n\n    Ok(last_return)\n}\n
===================================================================
diff --git a/src/compiler/compile_functions/process_lines.rs b/src/compiler/compile_functions/process_lines.rs
--- a/src/compiler/compile_functions/process_lines.rs	
+++ b/src/compiler/compile_functions/process_lines.rs	
@@ -113,7 +113,10 @@
                     ));
                 }
                 name_handler.destroy_local_variables(lines)?;
-                lines.push(Line::Return(Some((return_value.0, name_handler.type_table().get_type_size(return_value.1)?))));
+                lines.push(Line::Return(Some((
+                    return_value.0,
+                    name_handler.type_table().get_type_size(return_value.1)?,
+                ))));
             }
             BasicSymbol::Keyword(Keyword::Let) => {
                 if line.len() < 2 {
Index: src/compiler/compile_functions/name_handler.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::basic_ast::symbol::{BasicSymbol, NameAccessType, NameType};\nuse crate::compiler::compile_functions::{FunctionHolder, Line};\nuse crate::parser::line_info::LineInfo;\nuse crate::processor::custom_types::Int;\nuse crate::processor::processor::ProcessorError;\nuse crate::processor::type_builder::{Type, TypeTable, TypedFunction};\nuse either::{Either, Left, Right};\nuse std::collections::HashSet;\nuse crate::utils::align;\n\npub struct NameHandler {\n    type_table: TypeTable,\n    args: Vec<(String, isize, (isize, usize))>,\n    local_variables: Vec<(String, isize, (isize, usize))>,\n    local_variables_size: usize,\n    used_functions: HashSet<isize>,\n    uid: usize,\n}\n\nimpl NameHandler {\n    pub fn new(type_table: TypeTable) -> NameHandler {\n        NameHandler {\n            type_table,\n            args: Vec::new(),\n            local_variables: Vec::new(),\n            local_variables_size: 0,\n            used_functions: HashSet::new(),\n            uid: 0,\n        }\n    }\n\n    pub fn set_args(&mut self, args: Vec<(String, isize, (isize, usize))>) {\n        self.args = args;\n    }\n\n    pub fn reset(&mut self) {\n        self.uid = 0;\n        self.args.clear();\n        self.local_variables.clear();\n        self.local_variables_size = 0;\n    }\n\n    pub fn get_uid(&mut self) -> usize {\n        self.uid += 1;\n        self.uid - 1\n    }\n\n    pub fn type_table(&self) -> &TypeTable {\n        &self.type_table\n    }\n\n    pub fn local_variable_space(&self) -> usize {\n        self.local_variables_size\n    }\n\n    pub fn add_local_variable(\n        &mut self,\n        name: Option<String>,\n        _type: (isize, usize),\n        lines: &mut Vec<Line>,\n    ) -> Result<isize, ProcessorError> {\n        let size = align(self.type_table.get_type_size(_type)?, 8);\n        let addr = -(self.local_variables_size as isize) - size as isize;\n        self.local_variables_size += size;\n        // lines.push(Line::InlineAsm(vec![format!(\"sub rsp, {}\", size)]));\n        if let Some(name) = name {\n            self.local_variables.push((name, addr, _type));\n        }\n        Ok(addr)\n    }\n\n    pub fn destroy_local_variables(&mut self, lines: &mut Vec<Line>) -> Result<(), ProcessorError> {\n        // return Ok(())\n\n        for (name, addr, (type_id, indirection)) in self.local_variables.clone() {\n            if indirection != 0 {\n                continue;\n            }\n            let t = self.type_table.get_type(type_id).unwrap();\n            if let Some(destructor) = t.get_destructor() {\n                let ref_ = self.add_local_variable(None, (type_id, 1), lines)?;\n\n                lines.push(Line::InlineAsm(Int::instantiate_local_ref(addr, ref_)));\n\n                lines.push(Line::NoReturnCall(\n                    destructor,\n                    -(self.local_variable_space() as isize),\n                    vec![(ref_, self.type_table.get_type_size((type_id, 1))?)],\n                    0\n                ));\n\n                self.use_function_id(destructor);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn name_variable(&mut self, name: String, addr: isize, _type: (isize, usize)) {\n        self.local_variables.push((name, addr, _type));\n    }\n\n    pub fn resolve_name<'b>(\n        &mut self,\n        function_holder: &'b FunctionHolder,\n        name: &'b Vec<(String, NameAccessType, NameType, usize)>,\n        line: &LineInfo,\n        lines: &mut Vec<Line>,\n    ) -> Result<\n        Either<\n            (isize, (isize, usize)),\n            (\n                &'b Box<dyn TypedFunction>,\n                Option<(isize, (isize, usize))>,\n                &'b Vec<Vec<(BasicSymbol, LineInfo)>>,\n            ),\n        >,\n        ProcessorError,\n    > {\n        let mut current_type: Option<(isize, usize)> = None;\n        let mut current_variable = None;\n        let mut return_func = None;\n\n        for (name, access_type, name_type, indirection) in name {\n            if return_func.is_some() {\n                // TODO\n                return Err(ProcessorError::NotImplemented(\n                    line.clone(),\n                    \"Using '.' or '#' after a function call\".to_string(),\n                ));\n            }\n\n            match name_type {\n                NameType::Normal => {\n                    if current_type.is_some() && current_variable.is_some() {\n                        let user_type = self\n                            .type_table\n                            .get_type(current_type.unwrap().0)\n                            .unwrap()\n                            .get_user_type()\n                            .ok_or(ProcessorError::AttributeDoesntExist(\n                                line.clone(),\n                                self.type_table\n                                    .get_type(current_type.unwrap().0)\n                                    .unwrap()\n                                    .get_name()\n                                    .to_string(),\n                                name.clone(),\n                            ))?;\n\n                        let t = user_type\n                            .get_attribute_offset_and_type(name, &self.type_table)?\n                            .ok_or(ProcessorError::AttributeDoesntExist(\n                                line.clone(),\n                                self.type_table\n                                    .get_type(current_type.unwrap().0)\n                                    .unwrap()\n                                    .get_name()\n                                    .to_string(),\n                                name.clone(),\n                            ))?;\n\n                        if current_type.unwrap().1 > 0 {\n                            let ref_addr = self\n                                .add_local_variable(None, (t.1 .0, current_type.unwrap().1), lines)\n                                .unwrap();\n                            lines.push(Line::InlineAsm(Int::instantiate_ref(\n                                current_variable.unwrap(),\n                                t.0 as isize,\n                                ref_addr,\n                            )));\n                            current_variable = Some(ref_addr);\n                            current_type = Some((t.1 .0, current_type.unwrap().1 + t.1 .1));\n                        } else {\n                            current_variable = Some(current_variable.unwrap() + (t.0 as isize));\n                            current_type = Some(t.1);\n                        }\n                    } else if current_type.is_some() {\n                        return Err(ProcessorError::AttemptedTypeAttribAccess(line.clone()));\n                    } else if let Some((_, addr, _type)) = self\n                        .local_variables\n                        .iter()\n                        .rev()\n                        .chain(self.args.iter())\n                        .find(|(n, _, _)| n == name)\n                    {\n                        // println!(\"{}, {}\", addr, _type);\n                        current_variable = Some(*addr);\n                        current_type = Some(*_type);\n                    } else if let Some(_type) = self.type_table.get_id_by_name(name) {\n                        current_variable = None;\n                        current_type = Some((_type, *indirection));\n                    } else {\n                        return Err(ProcessorError::NameNotFound(line.clone(), name.clone()));\n                    }\n                }\n                NameType::Function(contents) => {\n                    if let Some(func) = function_holder\n                        .functions_table()\n                        .get(&current_type.map(|x| x.0))\n                        .unwrap()\n                        .get(name)\n                    {\n                        let default_arg = if matches!(access_type, NameAccessType::Normal) {\n                            if current_variable.is_none() {\n                                return Err(ProcessorError::TypeNonStaticFunctionCall(\n                                    line.clone(),\n                                ));\n                            }\n                            Some((current_variable.unwrap(), current_type.unwrap()))\n                        } else {\n                            None\n                        };\n                        return_func = Some((\n                            function_holder.functions().get(func).unwrap(),\n                            default_arg,\n                            contents,\n                        ));\n                    }\n                }\n            }\n        }\n\n        if let Some(return_func) = return_func {\n            return Ok(Right(return_func));\n        }\n\n        Ok(Left((\n            current_variable.ok_or(ProcessorError::StandaloneType(line.clone()))?,\n            current_type.unwrap(),\n        )))\n    }\n\n    pub fn use_function_id(&mut self, id: isize) {\n        self.used_functions.insert(id);\n    }\n\n    pub fn use_function(&mut self, func: &Box<dyn TypedFunction>) {\n        if !func.is_inline() {\n            self.used_functions.insert(func.get_id());\n        }\n    }\n\n    pub fn used_functions(&self) -> &HashSet<isize> {\n        &self.used_functions\n    }\n}\n
===================================================================
diff --git a/src/compiler/compile_functions/name_handler.rs b/src/compiler/compile_functions/name_handler.rs
--- a/src/compiler/compile_functions/name_handler.rs	
+++ b/src/compiler/compile_functions/name_handler.rs	
@@ -4,9 +4,9 @@
 use crate::processor::custom_types::Int;
 use crate::processor::processor::ProcessorError;
 use crate::processor::type_builder::{Type, TypeTable, TypedFunction};
+use crate::utils::align;
 use either::{Either, Left, Right};
 use std::collections::HashSet;
-use crate::utils::align;
 
 pub struct NameHandler {
     type_table: TypeTable,
@@ -86,7 +86,7 @@
                     destructor,
                     -(self.local_variable_space() as isize),
                     vec![(ref_, self.type_table.get_type_size((type_id, 1))?)],
-                    0
+                    0,
                 ));
 
                 self.use_function_id(destructor);
Index: src/compiler/generate_asm.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::compiler::compile_functions::{Line, UserFunction};\nuse crate::utils::align;\n\npub struct Output {\n    inner: String,\n}\n\nimpl Default for Output {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Output {\n    pub fn new() -> Output {\n        Output {\n            inner: String::new(),\n        }\n    }\n\n    pub fn new_with_name(id: isize, name: &str) -> Output {\n        Output {\n            inner: format!(\"{}: ; {}\\n\", get_function_name(id), name),\n        }\n    }\n\n    pub fn push(&mut self, string: &str) {\n        self.inner.push('\\t');\n        self.inner += string;\n        self.inner.push('\\n');\n    }\n}\n\nimpl From<Output> for String {\n    fn from(value: Output) -> Self {\n        value.inner\n    }\n}\n\npub fn get_function_name(id: isize) -> String {\n    if id == 0 {\n        return \"main\".to_string();\n    }\n    let sign = if id < 0 { \"__\" } else { \"_\" };\n    format!(\"{sign}{}\", id.abs())\n}\n\npub fn get_function_sublabel(id: isize, label: &str) -> String {\n    let mut base = if id == 0 {\n        \"main\".to_string()\n    } else {\n        let sign = if id < 0 { \"_\" } else { \"\" };\n        format!(\".{sign}{}\", id.abs())\n    };\n\n    base.push('.');\n    base += label;\n    base\n}\n\npub fn get_local_address(addr: isize) -> String {\n    let sign = if addr >= 0 { \"+\" } else { \"\" };\n    format!(\"rbp{sign}{addr}\")\n}\n\npub fn compile_user_function(function: &UserFunction) -> String {\n    let mut output = Output::new_with_name(function.id, &function.name);\n    output.push(\"push rbp\");\n    output.push(\"mov rbp, rsp\");\n    output.push(&format!(\n        \"sub rsp, {}\",\n        align(function.local_variable_size, 16)    \n    ));\n\n    let mut last_return = false;\n    for line in &function.lines {\n        last_return = false;\n        match line {\n            Line::ReturnCall(function, start_addr, local_args, ret_size, return_addr) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\n                    \"; [return call] {} , {:?}, {}\",\n                    *function, local_args, *return_addr\n                ));\n                \n                let mut sum = local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);\n                \n                // Ensure 16-byte alignment\n                // if (sum / 8) % 2 != 0 {\n                //     sum += 8;\n                //     t += 8;\n                //     output.push(\"push qword 0\");\n                // }\n                \n                // Push args to stack\n                for (local_addr, size) in local_args.iter().rev() {\n                    let mut local_addr = *local_addr;\n                    let mut size = *size as isize;\n                    local_addr += size;\n                    local_addr -= 8;\n                    while size > 0 {\n                        output.push(&format!(\n                            \"mov rax, qword [{}]\",\n                            get_local_address(local_addr)\n                        ));\n                        output.push(\"push rax\");\n                        local_addr -= 8;\n                        size -= 8;\n                    }\n                }\n\n                // Allocate return space\n                for _ in 0..(ret_size.div_ceil(8)) {\n                    output.push(\"push 0\");\n                }\n                \n                // Call\n                output.push(&format!(\"call {}\", get_function_name(*function)));\n\n                // Move return value\n                local_copy(&mut output, *start_addr - sum as isize, *return_addr, *ret_size);\n                \n                // Release stack space used\n                output.push(&format!(\n                    \"add rsp, {}\",\n                    sum\n                ));\n            }\n            Line::NoReturnCall(function, start_addr, local_args, ret_size) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\n                    \"; [no return call] {} , {:?}, {}\",\n                    *function, local_args, *ret_size\n                ));\n\n                let mut sum = local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);\n\n                // Ensure 16-byte alignment\n                // if (sum / 8) % 2 != 0 {\n                //     output.push(\"push qword 0\");\n                //     sum += 8;\n                // }\n\n                // Push args to stack\n                for (local_addr, size) in local_args.iter().rev() {\n                    let mut local_addr = *local_addr;\n                    let mut size = *size as isize;\n                    local_addr += size;\n                    local_addr -= 8;\n                    while size > 0 {\n                        output.push(&format!(\n                            \"mov rax, qword [{}]\",\n                            get_local_address(local_addr)\n                        ));\n                        output.push(\"push rax\");\n                        local_addr -= 8;\n                        size -= 8;\n                    }\n                }\n\n                // Allocate return space\n                for _ in 0..(ret_size.div_ceil(8)) {\n                    output.push(\"push 0\");\n                }\n\n                // Call\n                output.push(&format!(\"call {}\", get_function_name(*function)));\n\n                // Release stack space used\n                if sum != 0 {\n                    output.push(&format!(\n                        \"add rsp, {}\",\n                        sum\n                    ));\n                }\n            }\n            Line::Copy(local_from, local_to, amount) => {\n                local_copy(&mut output, *local_from, *local_to, *amount);\n            }\n            Line::DynFromCopy(local_dyn_from, local_to, amount) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\n                    \"; [dyn from copy] {} , {}, {}\",\n                    *local_dyn_from, *local_to, *amount\n                ));\n                let mut done = 0;\n                output.push(&format!(\n                    \"mov r9, qword [{}]\",\n                    get_local_address(*local_dyn_from)\n                ));\n                while done < *amount {\n                    output.push(&format!(\"mov rax, qword [r9+{}]\", done));\n                    output.push(&format!(\n                        \"mov qword [{}], rax\",\n                        get_local_address(*local_to + (done as isize))\n                    ));\n                    done += 8;\n                }\n            }\n            Line::DynToCopy(local_from, local_dyn_to, amount) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\n                    \"; [dyn to copy] {} , {}, {}\",\n                    *local_from, *local_dyn_to, *amount\n                ));\n                let mut done = 0;\n                output.push(&format!(\n                    \"mov r9, qword [{}]\",\n                    get_local_address(*local_dyn_to)\n                ));\n                while done < *amount {\n                    output.push(&format!(\n                        \"mov rax, qword [{}]\",\n                        get_local_address(*local_from + (done as isize))\n                    ));\n                    output.push(&format!(\"mov qword [r9+{}], rax\", done));\n                    done += 8;\n                }\n            }\n            Line::Return(local_return_val) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\"; [return] {:?}\", *local_return_val));\n                last_return = true;\n                if function.id == 0 {\n                    output.push(&format!(\n                        \"mov rcx, [{}]\",\n                        get_local_address(local_return_val.unwrap().0)\n                    ));\n                    output.push(\"call ExitProcess\");\n                } else {\n                    if let Some(val) = local_return_val {\n                        local_copy(&mut output, val.0, 16, val.1);\n                    }\n                    output.push(\"leave\");\n                    output.push(\"ret\");\n                }\n            }\n            Line::HeapAlloc(amount, local_ref_addr) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\"; [heap alloc] {} , {}\", *amount, *local_ref_addr));\n                output.push(\"call GetProcessHeap\"); // Get process heap\n                output.push(\"mov rcx, rax\"); // Heap handle\n                output.push(\"mov rdx, 0\"); // Flags\n                output.push(&format!(\"mov r8, {}\", *amount));\n                output.push(\"call HeapAlloc\");\n                output.push(&format!(\n                    \"mov qword [{}], rax\",\n                    get_local_address(*local_ref_addr)\n                ));\n            }\n            Line::HeapDealloc(local_ref_addr, local_success_bool) => {\n                #[cfg(debug_assertions)]\n                output.push(&format!(\n                    \"; [heap dealloc] {} , {}\",\n                    *local_ref_addr, *local_success_bool\n                ));\n                output.push(\"call GetProcessHeap\"); // Get process heap\n                output.push(\"mov rcx, rax\"); // Heap handle\n                output.push(\"mov rdx, 0\"); // Flags\n                output.push(&format!(\n                    \"mov r8, qword [{}]\",\n                    get_local_address(*local_ref_addr)\n                ));\n                output.push(\"call HeapFree\");\n                output.push(\"cmp rax, 0\");\n                output.push(\"mov rcx, 0\");\n                output.push(\"setz cl\");\n                output.push(&format!(\n                    \"mov qword [{}], rcx\",\n                    get_local_address(*local_success_bool)\n                ))\n            }\n            Line::InlineAsm(asm) => {\n                #[cfg(debug_assertions)]\n                output.push(\"; [inline asm]\");\n                for line in asm {\n                    output.push(line);\n                }\n            }\n            Line::Annotation(annotation) => {\n                output.push(&format!(\"; '{}'\", annotation));\n            }\n        }\n    }\n\n    if last_return {\n        return output.into();\n    }\n\n    if function.id == 0 {\n        output.push(\"mov rcx, 0\");\n        output.push(\"call ExitProcess\");\n        output.into()\n    } else {\n        output.push(\"leave\");\n        output.push(\"ret\");\n        output.into()\n    }\n}\n\nfn local_copy(output: &mut Output, local_from: isize, local_to: isize, amount: usize) {\n    #[cfg(debug_assertions)]\n    output.push(&format!(\n        \"; [local copy] {} , {}, {}\",\n        local_from, local_to, amount\n    ));\n    let mut done = 0;\n    while done < amount {\n        output.push(&format!(\n            \"mov rax, qword [{}]\",\n            get_local_address(local_from + (done as isize))\n        ));\n        output.push(&format!(\n            \"mov qword [{}], rax\",\n            get_local_address(local_to + (done as isize))\n        ));\n        done += 8;\n    }\n}\n
===================================================================
diff --git a/src/compiler/generate_asm.rs b/src/compiler/generate_asm.rs
--- a/src/compiler/generate_asm.rs	
+++ b/src/compiler/generate_asm.rs	
@@ -69,7 +69,7 @@
     output.push("mov rbp, rsp");
     output.push(&format!(
         "sub rsp, {}",
-        align(function.local_variable_size, 16)    
+        align(function.local_variable_size, 16)
     ));
 
     let mut last_return = false;
@@ -82,16 +82,17 @@
                     "; [return call] {} , {:?}, {}",
                     *function, local_args, *return_addr
                 ));
-                
-                let mut sum = local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);
-                
+
+                let mut sum =
+                    local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);
+
                 // Ensure 16-byte alignment
                 // if (sum / 8) % 2 != 0 {
                 //     sum += 8;
                 //     t += 8;
                 //     output.push("push qword 0");
                 // }
-                
+
                 // Push args to stack
                 for (local_addr, size) in local_args.iter().rev() {
                     let mut local_addr = *local_addr;
@@ -113,18 +114,20 @@
                 for _ in 0..(ret_size.div_ceil(8)) {
                     output.push("push 0");
                 }
-                
+
                 // Call
                 output.push(&format!("call {}", get_function_name(*function)));
 
                 // Move return value
-                local_copy(&mut output, *start_addr - sum as isize, *return_addr, *ret_size);
-                
+                local_copy(
+                    &mut output,
+                    *start_addr - sum as isize,
+                    *return_addr,
+                    *ret_size,
+                );
+
                 // Release stack space used
-                output.push(&format!(
-                    "add rsp, {}",
-                    sum
-                ));
+                output.push(&format!("add rsp, {}", sum));
             }
             Line::NoReturnCall(function, start_addr, local_args, ret_size) => {
                 #[cfg(debug_assertions)]
@@ -133,7 +136,8 @@
                     *function, local_args, *ret_size
                 ));
 
-                let mut sum = local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);
+                let mut sum =
+                    local_args.iter().map(|x| align(x.1, 8)).sum::<usize>() + align(*ret_size, 8);
 
                 // Ensure 16-byte alignment
                 // if (sum / 8) % 2 != 0 {
@@ -168,10 +172,7 @@
 
                 // Release stack space used
                 if sum != 0 {
-                    output.push(&format!(
-                        "add rsp, {}",
-                        sum
-                    ));
+                    output.push(&format!("add rsp, {}", sum));
                 }
             }
             Line::Copy(local_from, local_to, amount) => {
Index: src/compiler/compile_functions/assignment.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::basic_ast::symbol::BasicSymbol;\nuse crate::compiler::compile_functions::name_handler::NameHandler;\nuse crate::compiler::compile_functions::{evaluate, operators, FunctionHolder, Line};\nuse crate::parser::line_info::LineInfo;\nuse crate::processor::processor::ProcessorError;\nuse either::Left;\n\npub fn process_assignment(\n    lines: &mut Vec<Line>,\n    name_handler: &mut NameHandler,\n    function_holder: &FunctionHolder,\n    line: &[(BasicSymbol, LineInfo)],\n    is_ref: bool,\n) -> Result<(), ProcessorError> {\n    if line.len() < 2 {\n        panic!()\n    }\n\n    match &line[1].0 {\n        BasicSymbol::Assigner(assigner) => {\n            let name = match &line[0].0 {\n                BasicSymbol::Name(name) => name,\n                _ => return Err(ProcessorError::NonNameAssignment(line[0].1.clone())),\n            };\n            let Left(variable) =\n                name_handler.resolve_name(function_holder, name, &line[0].1, lines)?\n            else {\n                return Err(ProcessorError::AssignToNonVariable(line[0].1.clone()));\n            };\n\n            let (original_variable, variable) = if is_ref {\n                if variable.1 .1 == 0 {\n                    return Err(ProcessorError::CantDerefNonRef(line[0].1.clone()));\n                }\n\n                let new_type = (variable.1 .0, variable.1 .1 - 1);\n                let non_ref = name_handler.add_local_variable(None, new_type, lines).unwrap();\n                lines.push(Line::DynFromCopy(\n                    variable.0,\n                    non_ref,\n                    name_handler.type_table().get_type_size(new_type)?,\n                ));\n                (Some(variable), (non_ref, new_type))\n            } else {\n                (None, variable)\n            };\n\n            if line.len() < 3 {\n                return Err(ProcessorError::NoAssignmentRHS(line[1].1.clone()));\n            }\n            if let Some(assigner) = assigner {\n                let result =\n                    evaluate::evaluate(&line[2..], lines, name_handler, function_holder, None)?\n                        .ok_or(ProcessorError::DoesntEvaluate(line[2].1.clone()))?;\n                operators::evaluate_operation(\n                    variable,\n                    (assigner, &line[1].1),\n                    Some(result),\n                    lines,\n                    name_handler,\n                    function_holder,\n                    Some(variable),\n                )?;\n            } else {\n                evaluate::evaluate(\n                    &line[2..],\n                    lines,\n                    name_handler,\n                    function_holder,\n                    Some(variable),\n                )?;\n            }\n\n            if is_ref {\n                lines.push(Line::DynToCopy(\n                    variable.0,\n                    original_variable.unwrap().0,\n                    name_handler.type_table().get_type_size(variable.1)?,\n                ));\n            }\n\n            Ok(())\n        }\n        _ => {\n            panic!()\n        }\n    }\n}\n
===================================================================
diff --git a/src/compiler/compile_functions/assignment.rs b/src/compiler/compile_functions/assignment.rs
--- a/src/compiler/compile_functions/assignment.rs	
+++ b/src/compiler/compile_functions/assignment.rs	
@@ -34,7 +34,9 @@
                 }
 
                 let new_type = (variable.1 .0, variable.1 .1 - 1);
-                let non_ref = name_handler.add_local_variable(None, new_type, lines).unwrap();
+                let non_ref = name_handler
+                    .add_local_variable(None, new_type, lines)
+                    .unwrap();
                 lines.push(Line::DynFromCopy(
                     variable.0,
                     non_ref,
Index: src/utils.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use std::ops::{Add, Rem, Sub};\n#[macro_export]\nmacro_rules! time {\n    ($($tts:tt)*) => {\n        let t = Instant::now();\n        $($tts)*;\n        let end = t.elapsed();\n        println!(\"Completed [{:?}]\", end);\n    };\n}\n\npub fn align<T: Copy + Sub<Output=T> + Rem<Output=T> + Add<Output=T>>(num: T, alignment: T) -> T {\n    num + (alignment - (num % alignment)) % alignment\n}
===================================================================
diff --git a/src/utils.rs b/src/utils.rs
--- a/src/utils.rs	
+++ b/src/utils.rs	
@@ -9,6 +9,9 @@
     };
 }
 
-pub fn align<T: Copy + Sub<Output=T> + Rem<Output=T> + Add<Output=T>>(num: T, alignment: T) -> T {
+pub fn align<T: Copy + Sub<Output = T> + Rem<Output = T> + Add<Output = T>>(
+    num: T,
+    alignment: T,
+) -> T {
     num + (alignment - (num % alignment)) % alignment
-}
\ No newline at end of file
+}
