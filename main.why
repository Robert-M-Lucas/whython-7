struct Node {
    cur: int,
    last: bool,
    next: $Node
}

struct LL {
    base: $Node,
    has_first: bool
}

impl LL {
    fn new() ~ LL {
        return @LL {
            0,
            false
        };
    }

    fn add(self, next: int) {
        let new_node: Node = @Node {
            next,
            true,
            0
        };

        if (!(*self.has_first)) {
            *self.base = ^new_node;
            *self.has_first = true;
            return;
        };

        let curr: $Node = *self.base;
        while (!(*curr.last)) {
            curr = *curr.next;
        };

        *curr.last = false;
        *curr.next = ^new_node;
    }

    fn print(self) {
        if (!(*self.has_first)) {
            return;
        };

        let curr: $Node = *self.base;
        printi(*curr.cur);

        while (!(*curr.last)) {
            curr = *curr.next;
            printi(*curr.cur);
        };
    }

    fn destroy(self) {
       let a: bool = *self.has_first;

        if (!(*self.has_first)) {
            printi(119);
            return;
        };
        printi(120);

        let curr: $Node = *self.base;

        printi(121);

        while (!(*curr.last)) {
            printi(122);
            let prev: $Node = curr;
            curr = *curr.next;
            ¬prev;
        };

        printi(122);

        ¬curr;

        printi(123);

        *self.has_first = false;
        *self.base = 0;
    }
}

fn test() {
    let ll: LL = LL#new();
}

fn main() ~ int {
    test();

    return 7;
}